package project.jun.dao.result;import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.Set;import java.util.TreeSet;import org.apache.ibatis.metadata.result.MetaData;import project.jun.util.HoFomatter;import project.jun.util.HoUtil;public class HoMapList extends HashMap {	/**	 * 	 */	private static final long serialVersionUID = -8415916320517648658L;	private MetaData metaData = null;	private Map      displayFormat          = null;	/**	 * HoMapList 생성자.	 */	public HoMapList() {		super();	}	/**	 * HoMapList 생성자.	 */	public HoMapList(HoList hoList, String key) {		super();		for (int i = 0; i < hoList.size(); i++) {			this.setValue(hoList.getString(i, key), hoList.toHoMap(i));		}	}	/**	 * ResultSetMetaData정보를 set	 * 	 * @return	 */	public void setMetaData(MetaData metaData) {		this.metaData = metaData;	}	/**	 * 쿼리결과의 ResultSetMetaData정보를 return	 * 	 * @return	 */	public MetaData getMetaData() {		return this.metaData;	}	/**	 * Data가 조회될때의 데이터 형태 yyyy/MM/dd or MM/dd/yyyy or MMM/dd/yyyy  or yyyy-MM-dd	 * @return	 */	public Map getDisplayFormat() {		return this.displayFormat;	}	/**	 * Data가 조회될때의 데이터 형태 yyyy/MM/dd or MM/dd/yyyy or MMM/dd/yyyy  or yyyy-MM-dd	 * @return	 */	public void setDisplayFormat(Map displayFormat) {		if( this.displayFormat == null ) {			this.displayFormat          = new HashMap();		}		this.displayFormat.putAll(displayFormat);	}	/**	 * Result를 통하여 "0"번째 결과값을 얻어가도록 처리한다.	 * 	 * @param s	 *            value값에 대한 유일한 식별자	 * @param i	 *            객체의 위치	 * @param obj	 *            default객체	 */	public Object getValue(String key) {		return getValue(key, 0);	}	/**	 * Result를 통하여 i번째 결과값을 얻어가도록 처리한다.	 * 	 * @param s	 *            value값에 대한 유일한 식별자	 * @param i	 *            객체의 위치	 * @param obj	 *            default객체	 * @return 결과반환값	 */	public Object getValue(String key, int i) {		ArrayList alist = (ArrayList) super.get(key);		if (alist == null)			return null;		try {			return alist.get(i);		} catch (IndexOutOfBoundsException ex) {			return null;		}	}	/**	 * Result를 통하여 i번째 결과값을 얻어가도록 처리한다.	 * 	 * @param s	 *            value값에 대한 유일한 식별자	 * @param i	 *            객체의 위치	 * @param obj	 *            default객체	 * @return 결과반환값	 */	public HoMap getHoMap(String key, int i) {		ArrayList alist = (ArrayList) super.get(key);		if (alist == null)			return null;		try {			HoMap hoMap = (HoMap) alist.get(i);			hoMap.setMetaData(this.getMetaData());			hoMap.setDisplayFormat(this.getDisplayFormat());			return hoMap;		} catch (IndexOutOfBoundsException ex) {			return null;		} catch (ClassCastException ex) {			return null;		}	}	/**	 * Result에서 key값에 해당하는HoList를 return한다.	 * 	 * @param key	 * @return	 */	public HoList getHoList(String key) {		List alist = new ArrayList();		alist.add(this.getMetaData());		alist.addAll(getList(key));		HoList hoList = new HoList(alist);		hoList.setDisplayFormat(this.getDisplayFormat());		return hoList;	}	/**	 * Result에서 key값에 해당하는 HoList를 return한다.	 * 	 * @param key	 * @return	 */	public HoList getHoList(Object key) {		return getHoList(key.toString());	}	/**	 * Result에서 key값에 해당하는 List를 return한다.	 * 	 * @param key	 * @return	 */	public List getList(String key) {		List alist = (List) super.get(key);		return alist;	}	/**	 * Result에서 key값에 해당하는 List를 return한다.	 * 	 * @param key	 * @return	 */	public List getList(Object key) {		return getList(key.toString());	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 String으로 가져온다.	 * 	만약 결과값이 null일 경우 ""를 return한다.	 * </pre>	 * 	 * @param key	 *            value값에 대한 유일한 식별자	 * @param i	 *            객체의 위치	 * @param column	 *            i번째 객체의 Map에서 유일한 식별자.	 * @return	 * @exception	 * @see	 */	public String getString(String key, int i, String column) {		return getString(key, i, column, "");	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 String으로 가져온다.	 * 	만약 결과값이 null일 경우 ""를 return한다.	 * </pre>	 * 	 * @param key	 *            value값에 대한 유일한 식별자	 * @param i	 *            객체의 위치	 * @param column	 *            i번째 객체의 Map에서 유일한 식별자.	 * @return	 * @exception	 * @see	 */	public String getString(Object key, int i, String column) {		return getString(key.toString(), i, column, "");	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 String으로 가져온다.	 * </pre>	 * 	 * @param key	 *            value값에 대한 유일한 식별자	 * @param i	 *            객체의 위치	 * @param column	 *            i번째 객체의 Map에서 유일한 식별자.	 * @param defaultValue	 *            만약 i번째 객체의 Map에서 유일한 식별자에 해당하는 값이 null일 경우 return할 값.	 * @return	 * @exception	 * @see	 */	public String getString(String key, int i, String column, String defaultValue) {				HoMap hoMap = getHoMap(key, i);				if( hoMap != null ) {			return hoMap.getString(column, defaultValue);		} else {			return defaultValue;		}	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 html String으로 가져온다. 	 * 	만약 결과값이 null일 경우 ""를 return한다.	 * </pre>	 * 	 * @param key	 *            value값에 대한 유일한 식별자	 * @param i	 *            객체의 위치	 * @param column	 *            i번째 객체의 Map에서 유일한 식별자.	 * @return	 * @exception	 * @see	 */	public String getStringForHtml(String key, int i, String column) {		return getStringForHtml(key, i, column, "");	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 html String으로 가져온다. 	 * 	만약 결과값이 null일 경우 ""를 return한다.	 * </pre>	 * 	 * @param key	 *            value값에 대한 유일한 식별자	 * @param i	 *            객체의 위치	 * @param column	 *            i번째 객체의 Map에서 유일한 식별자.	 * @param defaultValue	 *            만약 i번째 객체의 Map에서 유일한 식별자에 해당하는 값이 null일 경우 return할 값.	 * @return	 * @exception	 * @see	 */	public String getStringForHtml(String key, int i, String column, String defaultValue) {		HoMap hoMap = getHoMap(key, i);				if( hoMap != null ) {			return hoMap.getStringForHtml(column);		} else {			return defaultValue;		}	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 escaped String으로 가져온다.	 * </pre>	 * 	 * @param key	 * @param i	 * @param column	 * @return	 * @exception	 * @see	 */	public String getStringForInput(String key, int i, String column) {		return getStringForInput(key, i, column, "");	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 escaped String으로 가져온다.	 * 	만약 결과값이 null일 경우 ""를 return한다.	 * </pre>	 * 	 * @param key	 * @param i	 * @param column	 * @return	 * @exception	 * @see	 */	public String getStringForInput(String key, int i, String column, String defaultValue) {		HoMap hoMap = getHoMap(key, i);				if( hoMap != null ) {			return hoMap.getStringForInput(column);		} else {			return defaultValue;		}	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 통화형태의 String으로 가져온다.	 * </pre>	 * 	 * @param key	 * @param i	 * @param column	 * @return	 * @exception	 * @see	 */	public String getCurrencyFormat(String key, int i, String column) {		HoMap hoMap = getHoMap(key, i);				if( hoMap != null ) {			return hoMap.getCurrencyFormat(column);		} else {			return "0";		}	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 소수점형태의 String으로 가져온다.	 * </pre>	 * 	 * @param key	 * @param i	 * @param column	 * @return	 */	public String getPointFormat(String key, int i, String column) {		HoMap hoMap = getHoMap(key, i);				if( hoMap != null ) {			return hoMap.getPointFormat(column);		} else {			return "0.00";		}	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 int으로 가져온다.	 * </pre>	 * 	 * @param key	 * @param i	 * @param column	 * @return	 * @exception	 * @see	 */	public int getInt(String key, int i, String column) {		HoMap hoMap = getHoMap(key, i);				if( hoMap != null ) {			return hoMap.getInt(column);		} else {			return 0;		}	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 long으로 가져온다.	 * </pre>	 * 	 * @param key	 * @param i	 * @param column	 * @return	 * @exception	 * @see	 */	public long getLong(String key, int i, String column) {		HoMap hoMap = getHoMap(key, i);				if( hoMap != null ) {			return hoMap.getLong(column);		} else {			return 0L;		}	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 double으로 가져온다.	 * </pre>	 * 	 * @param key	 * @param i	 * @param column	 * @return	 * @exception	 * @see	 */	public double getDouble(String key, int i, String column) {		HoMap hoMap = getHoMap(key, i);				if( hoMap != null ) {			return hoMap.getDouble(column);		} else {			return 0.0;		}	}	/**	 * Hashtable의 s값의 데이터를 put하도록 하며 실제 그안의 데이터를 순차값을 가진 ArrayList를 사용한다	 */	public void setValue(String key, Object obj) {		ArrayList alist = (ArrayList) super.get(key);		if (alist == null) {			alist = new ArrayList(10);			put(key, alist);		}		alist.add(obj);	}	/**	 * s값에 의하여 저장된 데이터의 사이즈를 구하도록 한다.	 */	public int size(String key) {		ArrayList alist = (ArrayList) super.get(key);		if (alist == null)			return 0;		else			return alist.size();	}	/**	 * 맵의 ArrayList의 크기중 가장 큰값을 구한다.	 **/	public int maxSize() {		Set keySet = super.keySet();		Iterator iter = keySet.iterator();		int max = 0;		int min = 0;		while (iter.hasNext()) {			min = ((ArrayList) super.get((String) iter.next())).size();			if (min > max) {				max = min;			}		}		return max;	}	/**	 * 전체 contents(ArrayList)의 크기구하기..	 **/	public int totalSize() {		Set keySet = super.keySet();		Iterator iter = keySet.iterator();		int size = 0;		while (iter.hasNext()) {			size += ((ArrayList) super.get((String) iter.next())).size();		}		return size;	}	/**	 * keySet의 정보를 Iterator로 return한다.	 * 	 * @return	 */	public Iterator keyIterator() {		return new TreeSet(super.keySet()).iterator();	}	/**	 * 'columnValue1', 'columnValue2', 'columnValue3' ... 형태로 return	 * 	 * @param idx	 * @return	 */	public String toJavaScriptArgString(String key, int idx) {		StringBuffer sb = new StringBuffer();		for (int i = 0; i < getMetaData().getColumnCount(); i++) {			if (i != 0) {				sb.append(',');			}			sb.append('\'');			sb.append(HoUtil.toJsonString(this.getString(key, idx,					getMetaData().getColumnName(i))));			sb.append('\'');		}		return sb.toString();	}	/**	 * { column_name1 : 'columnValue1', column_name2 : 'columnValue2',	 * column_name3 : 'columnValue3' ... }형태로 return	 * 	 * @param idx	 * @return	 */	public String toJavaScriptObject(String key, int idx) {		StringBuffer sb = new StringBuffer();		sb.append('{');		for (int i = 0; i < getMetaData().getColumnCount(); i++) {			if (i != 0) {				sb.append(',');			}			sb.append(getMetaData().getColumnName(i).toUpperCase());			sb.append(':');			sb.append('\'');			sb.append(HoUtil.toJsonString(this.getString(key, idx,					getMetaData().getColumnName(i))));			sb.append('\'');		}		sb.append('}');		return sb.toString();	}	/**	 * { column_name1 : 'columnValue1', column_name2 : 'columnValue2',	 * column_name3 : 'columnValue3' ... }형태로 return	 * 	 * @param idx	 * @return	 */	public String toJsonString(String key, int idx) {		StringBuffer sb = new StringBuffer();		for (int i = 0; i < getMetaData().getColumnCount(); i++) {			if (i != 0) {				sb.append(',');			}			sb.append(getMetaData().getColumnName(i).toUpperCase());			sb.append(':');			sb.append('\'');			sb.append(HoUtil.toJsonString(this.getString(key, idx,					getMetaData().getColumnName(i))));			sb.append('\'');		}		return sb.toString();	}	/**	 * Set에 해당하는 column을 가지고 { column_name1 : 'columnValue1', column_name2 :	 * 'columnValue2', column_name3 : 'columnValue3' ... }형태로 return	 * 	 * @param idx	 * @return	 */	public String toJavaScriptObject(Set set, String key, int idx) {		StringBuffer sb = new StringBuffer();		sb.append('{');		String setKey = null;		Iterator it = set.iterator();		for (int i = 0; it.hasNext(); i++) {			setKey = (String) it.next();			if (i != 0) {				sb.append(',');			}			sb.append(key);			sb.append(':');			sb.append('\'');			sb.append(HoUtil.toJsonString(this.getString(key, idx, setKey					.toUpperCase())));			sb.append('\'');		}		sb.append('}');		return sb.toString();	}	/**	 * { column_name1 : 'columnValue1', column_name2 : 'columnValue2',	 * column_name3 : 'columnValue3' ... }형태로 return	 * 	 * @param idx	 * @return	 */	public String toJsonString(Set set, String key, int idx) {		StringBuffer sb = new StringBuffer();		String setKey = null;		Iterator it = set.iterator();		for (int i = 0; it.hasNext(); i++) {			setKey = (String) it.next();			if (i != 0) {				sb.append(',');			}			sb.append(key);			sb.append(':');			sb.append('\'');			sb.append(HoUtil.toJsonString(this.getString(key, idx, setKey					.toUpperCase())));			sb.append('\'');		}		return sb.toString();	}	/**	 * Set에 해당하는 column을 가지고 { column_name1 : 'columnValue1', column_name2 :	 * 'columnValue2', column_name3 : 'columnValue3' ... }형태로 return	 * 	 * @param idx	 * @return	 */	public String toJavaScriptObject(String[] set, String key, int idx) {		StringBuffer sb = new StringBuffer();		sb.append('{');		for (int i = 0; i < set.length; i++) {			if (i != 0) {				sb.append(',');			}			sb.append(set[i]);			sb.append(':');			sb.append('\'');			sb.append(HoUtil.toJsonString(this.getString(key, idx, set[i]					.toUpperCase())));			sb.append('\'');		}		sb.append('}');		return sb.toString();	}	/**	 * Set에 해당하는 column을 가지고 { column_name1 : 'columnValue1', column_name2 :	 * 'columnValue2', column_name3 : 'columnValue3' ... }형태로 return	 * 	 * @param idx	 * @return	 */	public String toJson(String[] set, String key, int idx) {		StringBuffer sb = new StringBuffer();		for (int i = 0; i < set.length; i++) {			if (i != 0) {				sb.append(',');			}			sb.append(set[i]);			sb.append(':');			sb.append('\'');			sb.append(HoUtil.toJsonString(this.getString(key, idx, set[i]					.toUpperCase())));			sb.append('\'');		}		return sb.toString();	}	public String toNestedList(String connect) {		return toNestedList(connect, "item");	}	public String toNestedList(String connect, String itemName) {		return toNestedList(connect, itemName, "fs_Handler");	}	public String toNestedList(String connect, String itemName, String handler) {		StringBuffer sb = new StringBuffer();		List list = this.getList(connect);		sb.append("items : [");		for (int i = 0; i < list.size(); i++) {			if (i > 0) {				sb.append(", ");			}			sb.append('{');			sb.append(this.getHoMap(connect, i).toJson());			sb.append(", handler : " + handler + "\r\n");			if (this.size(connect) > 0) {				sb.append(", " + itemName + " : {");				sb.append(toNestedList(this.getString(connect, i, "MENU_ID"),						itemName, handler));				sb.append(" } ");			}			sb.append('}');		}		sb.append(']');		return sb.toString();	}	public String toNestedList(String connect, String itemName, String handler,			Set set) {		StringBuffer sb = new StringBuffer();		List list = this.getList(connect);		sb.append("items : [");		for (int i = 0; i < list.size(); i++) {			if (i > 0) {				sb.append(", ");			}			sb.append('{');			sb.append(this.getHoMap(connect, i).toJson(set));			if (!HoUtil.replaceNull(handler).equals("")) {				sb.append(", handler : " + handler + "\r\n");			}			if (this.size(connect) > 0) {				sb.append(", " + itemName + " : {");				sb.append(toNestedList(this.getString(connect, i, "MENU_ID"),						itemName, handler, set));				sb.append(" } ");			}			sb.append('}');		}		sb.append(']');		return sb.toString();	}	public String toNestedList(String connect, String itemName, String handler,			String[] set) {		StringBuffer sb = new StringBuffer();		List list = this.getList(connect);		sb.append("items : [");		for (int i = 0; i < list.size(); i++) {			if (i > 0) {				sb.append(", ");			}			sb.append('{');			sb.append(this.getHoMap(connect, i).toJson(set));			if (!HoUtil.replaceNull(handler).equals("")) {				sb.append(", handler : " + handler + "\r\n");			}			if (this.size(connect) > 0) {				sb.append(", " + itemName + " : {");				sb.append(toNestedList(this.getString(connect, i, "MENU_ID"),						itemName));				sb.append(" } ");			}			sb.append('}');		}		sb.append(']');		return sb.toString();	}	public String toNestedList(String connect, String itemName, String handler, String[][] set) {		StringBuffer sb = new StringBuffer();		List list = this.getList(connect);		sb.append("\r\n items : [");		for (int i = 0; i < list.size(); i++) {			if (i > 0) {				sb.append(", ");			}			sb.append('{');			sb.append(this.getHoMap(connect, i).toJson(set));			if (!HoUtil.replaceNull(handler).equals("")) {				sb.append(", handler : " + handler + "\r\n");			}			if (this.size(this.getString(connect, i, "MENU_ID")) > 0) {				sb.append(", " + itemName + " : {");				sb.append(toNestedList(this.getString(connect, i, "MENU_ID"),						itemName, handler, set));				sb.append('}');			}			sb.append('}');		}		sb.append(']');		return sb.toString();	}}