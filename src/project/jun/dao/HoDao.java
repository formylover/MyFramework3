package project.jun.dao;import java.sql.ResultSet;import java.sql.SQLException;import java.util.Date;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.StringTokenizer;import javax.naming.NamingException;import javax.sql.DataSource;import net.sf.ehcache.Cache;import org.apache.ibatis.session.ExecutorType;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.log4j.Logger;import org.mybatis.spring.SqlSessionTemplate;import org.mybatis.spring.support.SqlSessionDaoSupport;import project.jun.dao.parameter.HoQueryParameterMap;import project.jun.dao.result.HoMap;import project.jun.dao.result.HoList;import project.jun.dao.sql.HoSqlBatchImpl;import project.jun.was.result.exception.HoException;import org.springframework.jdbc.core.RowMapper;import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;import org.springframework.orm.ibatis.SqlMapClientTemplate;import org.springframework.orm.ibatis.support.SqlMapClientDaoSupport;public class HoDao extends SqlSessionDaoSupport { // SqlMapClientDaoSupport	protected static Logger          logger     = Logger.getLogger(HoDao.class);	NamedParameterJdbcTemplate jdbcTemplate = null;	private   Cache       cache;	private Map      cacheMap               = null;	private DataSource      dataSource               = null;	public Cache getCache() {		return cache;	}	public void setCache(Cache cache) {		this.cache = cache;	}/*	protected SqlMapClient getSql() {		return getSqlMapClient();	}*//*	protected SqlMapClientTemplate getSqlTemplate() {		return getSqlMapClientTemplate();	}*/		public void setDataSource(DataSource dataSource) {		this.dataSource = dataSource;	}			public DataSource getDataSource() {		return dataSource;	}			protected SqlSession getSqlTemplate() {		if( ((SqlSessionTemplate) getSqlSession()).getExecutorType() == ExecutorType.BATCH ) {			SqlSessionTemplate sessionTemplate = (SqlSessionTemplate) getSqlSession();			return sessionTemplate.getSqlSessionFactory().openSession(ExecutorType.REUSE);					} else {			return getSqlSession();		}	}	protected SqlSession getSqlTemplateBatch() {		SqlSessionTemplate sessionTemplate = (SqlSessionTemplate) getSqlSession();		return sessionTemplate.getSqlSessionFactory().openSession(ExecutorType.BATCH);	}	/*	 * 한건의 정보를 가져온다.	 * @see project.jun.dao.HoDao#queryForInfo(java.lang.String)	 */	protected HoMap queryForInfo(String sqlId) 	{				return new HoMap(getSqlTemplate().selectOne(sqlId));	}		/*	 * 한건의 정보를 가져온다.	 * @see project.jun.dao.HoDao#queryForInfo(java.lang.String)	 */	protected HoMap queryForInfo(String sqlId, HoQueryParameterMap value) 	{				return new HoMap(getSqlTemplate().selectOne(sqlId, value));	}	/**	 * 0건이상의 정보를 가져온다.	 */	protected HoList queryForList(String sqlId) 	{				return new HoList(getSqlTemplate().selectList(sqlId));	}		/**	 * 0건이상의 정보를 가져온다.	 */	protected HoList queryForList(String sqlId, HoQueryParameterMap value) 	{				return new HoList(getSqlTemplate().selectList(sqlId, value));	}	/**	 * CUD를 실행한다.	 * @param sql	 * @return	 * @throws NamingException	 * @throws SQLException	 * @throws HoException	 */	protected int update(String sqlId) 	{		return getSqlTemplate().update(sqlId);	}		/**	 * CUD를 실행한다.	 * @param sql	 * @return	 * @throws NamingException	 * @throws SQLException	 * @throws HoException	 */	protected int update(String sqlId, HoQueryParameterMap value )	{		return getSqlTemplate().update(sqlId, value);	}	/**	 * PROCEDURE를 실행한다.	 */	protected HoMap call(String sqlId, HoQueryParameterMap value) 	{				return new HoMap( getSqlTemplate().selectOne(sqlId, value));	}	/**	 * BATCH를 실행한다.	 * @param sql	 * @param values	 * @return	 * @throws NamingException	 * @throws SQLException	 * @throws HoException	 */	protected int  batch(String sqlId, HoQueryParameterMap [] valueses) throws NamingException, SQLException, HoException	{		int result = 0;						for( int i=0 ; i<valueses.length ; i++) {			result += getSqlTemplateBatch().update(sqlId, valueses[i]);		}				return result;	}		/**	 * 쿼리를 실행하기 위한 datasource를 설정한다.	 * @return	 */	protected NamedParameterJdbcTemplate getSqlRaw() {		if( this.jdbcTemplate == null ){ 			this.jdbcTemplate = new NamedParameterJdbcTemplate(this.getDataSource());		}				return this.jdbcTemplate;	}	/**	 *  SQL을 직접 실행하여 1건의 정보를 가져온다.	 * @param sql	 * @return	 * @throws NamingException	 * @throws SQLException	 * @throws HoException	 */	protected HoMap queryForInfoSql(String sql, HoQueryParameterMap value) throws NamingException, SQLException, HoException	{				logger.info(sql);		logger.info(value);		return new HoMap(getSqlRaw().queryForMap(sql, value));	}	/**	 *  SQL을 직접 실행하여 1건의 정보를 가져온다.	 * @param sql	 * @return	 * @throws NamingException	 * @throws SQLException	 * @throws HoException	 */	protected HoList queryForListSql(String sql, HoQueryParameterMap value) throws NamingException, SQLException, HoException	{				logger.info(sql);		logger.info(value);		return new HoList((List)getSqlRaw().queryForObject(sql, value, newRowMapper()));	}	/**	 * SQL을 직접 실행하여 CUD를 실행한다.	 * @param sql	 * @return	 * @throws NamingException	 * @throws SQLException	 * @throws HoException	 */	protected int updateSql(String sql, HoQueryParameterMap value) throws NamingException, SQLException, HoException	{		return getSqlRaw().update(sql, value);	}		/**	 * SQL을 직접 실행하여 batch를 실행한다.	 * @param sql	 * @param value	 * @return	 * @throws NamingException	 * @throws SQLException	 * @throws HoException	 */	protected int [] batchSql(String sql, List value) throws NamingException, SQLException, HoException	{		HoSqlBatchImpl batchImpl = new HoSqlBatchImpl(this.getDataSource(), sql, value);						batchImpl.update();				int [] result = batchImpl.getRowsAffected();				batchImpl.reset();				return result;	}		/**	 *  todo	 * @param rs	 * @param idx	 * @return	 */	public RowMapper newRowMapper() {		return new RowMapper() {			public Object mapRow(ResultSet rs, int row) {								return new Object();			}		}		 ;	}		public Map getCacheMap() {		if( this.cacheMap == null ) {			return new HashMap();		} else {			return cacheMap;		}	}	public void setCacheMap(Map cacheMap) {		this.cacheMap = cacheMap;	}	/**	 * sql을 실행한 쿼리를 debug한다.	 */	public String debug(String sql, Object [] params) {		StringBuffer sb = new StringBuffer();		StringBuffer result = new StringBuffer();		String [] str_comment = null;				if( sql.indexOf("/\\*") != -1 && sql.indexOf("\\*/") != -1) {			str_comment = sql.split("\\*/");						for( int i=0 ; i<str_comment.length ; i++ ) {				str_comment[i] = str_comment[i].substring(0, str_comment[i].indexOf("/\\*"));				sb.append(str_comment[i]);			}		} else {			sb.append(sql);		}				String [] str = sb.toString().split("\n");				sb = new StringBuffer();				for( int i=0 ; i<str.length ; i++ ) {			if( str[i].indexOf("--") != -1  ) {				str[i] = str[i].substring(0, str[i].indexOf("--"));			}			sb.append(str[i] +"\n");		}				StringTokenizer tok = new StringTokenizer(sb.toString(), "?");		String oneChunk = "";		int qMarkCount = 0;		try {			Object value;			while (tok.hasMoreTokens()) {								oneChunk = tok.nextToken();				result.append(oneChunk);								value = params[qMarkCount++];								if( value instanceof String || value instanceof Date ) {					result.append("'" + value +"' /* params */");								} else {					result.append(value + " /* params */");								}			}		} catch(Exception e) {			result.append(e.getMessage());		}				return result.toString();	}}