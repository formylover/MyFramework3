package project.jun.dao.parameter;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.Set;import org.apache.log4j.Logger;import project.jun.util.HoDate;import project.jun.was.config.HoConfig;import project.jun.was.parameter.HoParameter;/** * 맵을 쿼리파라미터로 처리하기위한 handler * @author USER00 * */public class HoQueryParameterHandler {	protected  Logger          logger     = Logger.getLogger(HoQueryParameterHandler.class);	Map map = null;	final static int STRING  = 1;	final static int CURRENCY   = 2; // 돈	final static int YMD    = 3; // 날짜	final static int HMS     = 4; // 시분초	final static int HM     = 5; // 시분	final static int SUFFIXED_STRING  = 9; //특정 문자열로 끝나는 문자	final static int ARRAY_ABLE    = 100;	final static int ARRAY_STRING  = 101;	final static int ARRAY_CURRENCY   = 102;	final static int ARRAY_YMD    = 103;	final static int ARRAY_HMS     = 104; // 시분초 	final static int ARRAY_HM     = 105; // 시분초 	// 세션에 파라미터의 날짜 형태를 저장하다록 구현. 	private String      parameterDateFormat  = "yyyy-MM-dd";	private HoConfig    hoConfig             = null;	private HoDate      hd                   = null;		private Map         displayFormat        = null;		// 배열로 만들경우 길이가 1또는 최대값이 아닐 경우의  처리정책	final static int IGNORE = 0;	final static int ARRAY  = 1;		// type	final static int SEARCH = 1;	final static int DETAIL = 2;	final static int ARRAYED = 3;	final static int META_DATA = 4;		private long pageNo = 0;	private long pageRowCnt = 0;	public HoQueryParameterHandler(HoParameter hoParam) {		this(hoParam.getParameterMap());		this.setHoConfig(hoParam.getHoConfig());						this.setParameterDateFormat(hoParam.getDefaut("DateFormat"));				this.displayFormat = this.getHoConfig().getDisplayFormat();		this.displayFormat.put("YMD", getParameterDateFormat());						try {			pageNo     = Long.parseLong(hoParam.get("pageNo", "0"));//페이지번호		}catch(Exception e) {					}		try {			pageRowCnt = Long.parseLong(hoParam.get("pageRowCnt", hoParam.getHoRequest().getSessionString("PAGE_ROW_CNT").equals("") ? "50" : hoParam.getHoRequest().getSessionString("PAGE_ROW_CNT")));//한페이지당 //		}catch(Exception e) {					}	}	public HoQueryParameterHandler(Map map) {		this.map = map;	}		public void put(String key, String entry ) {		this.map.put(key, entry);	}		public void putAll(Map map ) {		this.map.putAll(map);	}			public HoDate getHoDate() {		if( hd == null ) {			hd = new HoDate(this.getParameterDateFormat());		} else {			if( !hd.getFormat().equals(this.getParameterDateFormat()) ) {				hd.setFormat(this.getParameterDateFormat());			}		}		return hd;	}		/**	 * 파라미터의 형태를 구한다.	 * STRING / DATE / CURRENCY	 * @param name	 * @return	 */	public int getType(String name) {		return getType(name, "");	}	/**	 * 파라미터의 형태를 구한다.	 * STRING / DATE / CURRENCY	 * @param name	 * @return	 */	public int getType(String name, String suffix) {				// Session명일 경우 		if( this.getHoConfig()!=null 				&& name.toUpperCase().startsWith(this.getHoConfig().getSessionNamePrefix())) {			return STRING;		}		// 날짜배열로 판단되는 경우		else if( name.toUpperCase().endsWith("_YMD_ES")				|| name.toUpperCase().endsWith("_DT_ES")) {			return ARRAY_YMD;		} 		// 시분초배열로 판단되는 경우		else if( name.toUpperCase().endsWith("_HMS_ES")) {			return ARRAY_HMS;		} 		// 시분배열로 판단되는 경우		else if( name.toUpperCase().endsWith("_HM_ES")) {			return ARRAY_HM;		} 		// 금액배열로 판단되는 경우		else if( name.toUpperCase().endsWith("_AMT_ES")				|| name.toUpperCase().endsWith("_COST_ES")) {			return ARRAY_CURRENCY;		}		// 배열로 판단되는 경우		else if( name.toUpperCase().endsWith("_ES")) {			return ARRAY_STRING;		}		// 날짜로 판단되는 경우		else if( name.endsWith(suffix) 				&& ( name.toUpperCase().endsWith("_YMD"+suffix.toUpperCase())					|| name.toUpperCase().endsWith("_DT"+suffix.toUpperCase()))) {			return YMD;		} 		// 시분초로 판단되는 경우		else if(name.endsWith(suffix) && name.toUpperCase().endsWith("_HMS"+suffix.toUpperCase())) {			return HMS;		} 		// 시분로 판단되는 경우		else if( name.endsWith(suffix) && name.toUpperCase().endsWith("_HM"+suffix.toUpperCase())) {			return HM;		} 		// 금액으로 판단되는 경우		else if( name.endsWith(suffix) 				&& (name.toUpperCase().endsWith("_AMT"+suffix.toUpperCase())				|| name.endsWith(suffix) && name.toUpperCase().endsWith("_COST"+suffix.toUpperCase()))) {			return CURRENCY;		}		// _NM, _ID, _SEQ, _NO으로 끝날 경우에는 배열로 강제로 만들 수 있다.		else if( name.toUpperCase().endsWith("_CD")				|| name.toUpperCase().endsWith("_ID")				|| name.toUpperCase().endsWith("_NM")				|| name.toUpperCase().endsWith("_NO")				|| name.toUpperCase().endsWith("_SEQ")) {			return ARRAY_ABLE;		}		// suffix로 끝나는 문자열..		else if(!suffix.equals("") && !name.equals(suffix) && name.endsWith(suffix) ) {			return SUFFIXED_STRING;		}		// 기타의 경우 String		else {			return STRING;		}	}		/**	 * 파라미터를 parameterNamed의 대문자를 key로한 Map형태로 변환환다.	 */	public Map getMap() {		return this.map;	}	/**	 * 목록 검색을 위한 HoQueryParameterMap를 구한다.	 * 	 */	public HoQueryParameterMap getForSearch() {		return  makeHoQueryParameterMap(SEARCH);	}		/**	 * 상세조회를  위한 HoQueryParameterMap를 구한다.	 * 	 */	public HoQueryParameterMap getForDetail() {		return makeHoQueryParameterMap(DETAIL);	}	/**	 * 모든 Entry  값을 배열로 저장한다.	 */	public HoQueryParameterMap getForEntryArrayed() {		return makeHoQueryParameterMap( ARRAYED);	}	/** 	 *  HoQueryParameterMap 배열을  구한다.	 *  key를 기준으로 배열을 만든다. key에 해당하는 entry의 length가 다르면 배열로 넣는다. 	 *  key값에는 자동으로 "_ES"가  제거된다.	 * 			 */	public HoQueryParameterMap [] toArrayBaseKey(String keyName ) {		return toArrayBaseKey(keyName, ARRAY);	}	/**	 * MetaData 검색을 위한 HoQueryParameterMap를 구한다.	 * 	 */	public HoQueryParameterMap getForMetaData() {		return  makeHoQueryParameterMap(META_DATA);	}				/** TODO	 *  HoQueryParameterMap 배열을  구한다.	 *  key를 기준으로 배열을 만든다. key에 해당하는 entry의 length가 다르면 배열로 넣는다. 	 *  key값에는 자동으로 "_ES"가  제거된다.	 * 	 * @ param policy : entry의 길이가 최대값 또는 1이 아닐 경우의 처리 방법  	 * 		1. ARRAY : 값의 배열길이중 최대값을 기준으로 배열을 만든다. length가 최대값보다 다르면 배열로 넣는다. 	 * 		2. IGNORE  : 값의 배열길이중 최대값을 기준으로 배열을 만든다. length가 최대값보다 넣지 않는다. 	 * 			 */	public HoQueryParameterMap [] toArrayBaseKey(String keyName, int policy) {		int maxLength = getValues(keyName).length;				HoQueryParameterMap [] values = new  HoQueryParameterMap[maxLength];		String key = null;				Set keySet = this.map.keySet();		Iterator it = null;		int entryLength = 0;		for( int i=0 ; i<maxLength; i++ ) {			values[i] = new HoQueryParameterMap();			it = keySet.iterator();			while(it.hasNext()) {				key = (String) it.next();								try {					// entry의 길이.					entryLength = getValues(key).length ;										switch( getType(key)  ) {						case  ARRAY_YMD: 						case  YMD: 							if( entryLength == maxLength) {								values[i].put(key.toUpperCase().replaceAll("_ES", ""), getValuesDateFormat(getValues(key))[i]);							} else if(entryLength == 1) {								values[i].put(key.toUpperCase().replaceAll("_ES", ""), getDateFormat(get(key)));							} else {								if( policy == ARRAY ) {									values[i].put(key.toUpperCase().replaceAll("_ES", ""), getValuesDateFormat(getValues(key)));								} else if(policy == IGNORE) {									// 무시								}							}							break;						case  ARRAY_HMS: 						case  ARRAY_HM: 						case  ARRAY_CURRENCY: 						case  HMS: 						case  HM: 						case  CURRENCY: 							if( entryLength == maxLength) {								values[i].put(key.toUpperCase().replaceAll("_ES", ""), getValuesDelemeterFormat(getValues(key))[i]);							} else if(entryLength == 1) {								values[i].put(key.toUpperCase().replaceAll("_ES", ""), getDelemeterFormat(get(key)));							} else {								if( policy == ARRAY ) {									values[i].put(key.toUpperCase().replaceAll("_ES", ""), getValuesDelemeterFormat(getValues(key)));								} else if(policy == IGNORE) {									// 무시								}							}							break;						case  ARRAY_STRING: 						case  ARRAY_ABLE: 						case  STRING: 							if( entryLength == maxLength) {								values[i].put(key.toUpperCase().replaceAll("_ES", ""), getValues(key)[i]);							} else if(entryLength == 1) {								values[i].put(key.toUpperCase().replaceAll("_ES", ""), get(key));							} else {								if( policy == ARRAY ) {									values[i].put(key.toUpperCase().replaceAll("_ES", ""), getValues(key));								} else if(policy == IGNORE) {									// 무시								}							}							break;					}					} catch(Exception e) {									}							}				}				return values;	}		/** 	 *  HoQueryParameterMap 배열을  구한다.	 *  값의 배열길이중 최대값을 기준으로 배열을 만든다. length가 최대값보다 작으면 배열로 넣는다. 	 *  key값에는 자동으로 "_ES"가  제거된다.	 * 			 */	public HoQueryParameterMap [] toArrayBaseLength() {		return toArrayBaseLength(ARRAY);	}		/** TODO	 *  HoQueryParameterMap 배열을  구한다.	 *  key값에는 자동으로 "_ES"가  제거된다.	 * 	 * @ param policy : entry의 길이가 최대값 또는 1이 아닐 경우의 처리 방법  	 * 		1. ARRAY : 값의 배열길이중 최대값을 기준으로 배열을 만든다. length가 최대값보다 작으면 배열로 넣는다. 	 * 		2. IGNORE  : 값의 배열길이중 최대값을 기준으로 배열을 만든다. length가 최대값보다 넣지 않는다. 	 * 			 */	public HoQueryParameterMap [] toArrayBaseLength(int policy) {		int maxLength = maxLengthEntry();				HoQueryParameterMap [] values = new  HoQueryParameterMap[maxLength];		String key = null;				Set keySet = this.map.keySet();		Iterator it = null;		int entryLength = 0;		for( int i=0 ; i<maxLength; i++ ) {			values[i] = new HoQueryParameterMap();			it = keySet.iterator();			while(it.hasNext()) {				key = (String) it.next();								try {					// entry의 길이.					entryLength = getValues(key).length ;										switch( getType(key)  ) {						case  ARRAY_YMD: 						case  YMD: 							if( entryLength == maxLength) {								values[i].put(key.toUpperCase().replaceAll("_ES", ""), getValuesDateFormat(getValues(key))[i]);							} else if(entryLength == 1) {								values[i].put(key.toUpperCase().replaceAll("_ES", ""), getDateFormat(get(key)));							} else {								if( policy == ARRAY ) {									values[i].put(key.toUpperCase().replaceAll("_ES", ""), getValuesDateFormat(getValues(key)));								} else if(policy == IGNORE) {									// 무시								}							}							break;						case  ARRAY_HMS: 						case  ARRAY_HM: 						case  ARRAY_CURRENCY: 						case  HMS: 						case  HM: 						case  CURRENCY: 							if( entryLength == maxLength) {								values[i].put(key.toUpperCase().replaceAll("_ES", ""), getValuesDelemeterFormat(getValues(key))[i]);							} else if(entryLength == 1) {								values[i].put(key.toUpperCase().replaceAll("_ES", ""), getDelemeterFormat(get(key)));							} else {								if( policy == ARRAY ) {									values[i].put(key.toUpperCase().replaceAll("_ES", ""), getValuesDelemeterFormat(getValues(key)));								} else if(policy == IGNORE) {									// 무시								}							}							break;						case  ARRAY_STRING: 						case  ARRAY_ABLE: 						case  STRING: 							if( entryLength == maxLength) {								values[i].put(key.toUpperCase().replaceAll("_ES", ""), getValues(key)[i]);							} else if(entryLength == 1) {								values[i].put(key.toUpperCase().replaceAll("_ES", ""), get(key));							} else {								if( policy == ARRAY ) {									values[i].put(key.toUpperCase().replaceAll("_ES", ""), getValues(key));								} else if(policy == IGNORE) {									// 무시								}							}							break;					}					} catch(Exception e) {									}							}				}				return values;	}	/** TODO	 * 파라미터가 suffix로 끝나는 key를 기준으로 배열을 만든다.	 * @param suffix	 * @return	 */	public HoQueryParameterMap [] toArrayBaseSuffix(String baseParamName) {		return toArrayBaseSuffix(baseParamName, ARRAY);	}		/** TODO	 * 파라미터가 suffix로 끝나는 key를 기준으로 배열을 만든다.	 * @param suffix	 * @return	 */	public HoQueryParameterMap [] toArrayBaseSuffix(String keyName, int policy) {		int maxLength = getValues(keyName).length;				HoQueryParameterMap [] values = new  HoQueryParameterMap[maxLength];				String key = null;				Set keySet = this.map.keySet();		Iterator it = null;		int entryLength = 0;		for( int i=0 ; i<maxLength; i++ ) {			values[i] = new HoQueryParameterMap();			it = keySet.iterator();			values[i].put(keyName.toUpperCase().replaceAll("_ES", ""), getValues(key)[i]);			while(it.hasNext()) {				key = (String) it.next();				// keyName일 경우 break				if( key.equals(keyName)) {					break;				}				// entry의 길이.				entryLength = getValues(key).length ;				try {					switch( getType(key, "_"+getValues(keyName)[i])  ) {						case  ARRAY_YMD: 							if(entryLength == 1) {								values[i].put(key.toUpperCase().replaceAll("_ES", ""), getDateFormat(get(key)));							} else {								if( policy == ARRAY ) {									values[i].put(key.toUpperCase().replaceAll("_ES", ""), getValuesDateFormat(getValues(key)));								} else if(policy == IGNORE) {									// 무시								}							}							break;						case  ARRAY_HMS: 						case  ARRAY_HM: 						case  ARRAY_CURRENCY: 							if(entryLength == 1) {								values[i].put(key.toUpperCase().replaceAll("_ES", ""), getDelemeterFormat(get(key)));							} else {								if( policy == ARRAY ) {									values[i].put(key.toUpperCase().replaceAll("_ES", ""), getValuesDelemeterFormat(getValues(key)));								} else if(policy == IGNORE) {									// 무시								}							}							break;						case  ARRAY_STRING: 							if(entryLength == 1) {								values[i].put(key.toUpperCase().replaceAll("_ES", ""), get(key));							} else {								if( policy == ARRAY ) {									values[i].put(key.toUpperCase().replaceAll("_ES", ""), getValues(key));								} else if(policy == IGNORE) {									// 무시								}							}							break;						case  YMD: 							values[i].put(key.replaceAll("_"+getValues(keyName)[i], "").toUpperCase().replaceAll("_ES", ""), getDateFormat(get(key)));							break;						case  HMS: 						case  HM: 						case  CURRENCY: 							values[i].put(key.replaceAll("_"+getValues(keyName)[i], "").toUpperCase().replaceAll("_ES", ""), getDelemeterFormat(get(key)));							break;						case  ARRAY_ABLE: 						case  STRING: 							if(entryLength == 1) {								values[i].put(key.toUpperCase().replaceAll("_ES", ""), get(key));							} else {								if( policy == ARRAY ) {									values[i].put(key.toUpperCase().replaceAll("_ES", ""), getValues(key));								} else if(policy == IGNORE) {									// 무시								}							}							break;						case SUFFIXED_STRING :							values[i].put(key.replaceAll("_"+getValues(keyName)[i], "").toUpperCase().replaceAll("_ES", ""), get(key));														break;												}				} catch(Exception e) {									}							}			}		return values;	}		/**	 * value를 ","로 split하여 값이 ""가 아닌 경우만 골라서 새로운 배열로 만든다.	 * @param value	 * @return	 */	public String [] getSplit(String value) {		return getSplit(value, ",");	}		/**	 * key에 해당하는 값을 regexp로 split하여 값이 ""가 아닌 경우만 골라서 새로운 배열로 만든다.	 * @param value	 * @return	 */	public String [] getSplit(String value, String regexp) {		List list = new ArrayList();				String [] splited = value.split(regexp);				for( int i=0 ; i<splited.length ; i++) {			if( !splited[i].equals("")) {				list.add(splited[i]);			}		}		String [] array = new String[list.size()];				System.arraycopy(list.toArray(), 0, array, 0, list.size());		return array;	}		public String get(String key) {		Object obj = this.map.get(key);		if( obj instanceof String ) {			return (String) obj;		} else if( obj instanceof String[] ) {			return ((String[])obj)[0];		} else {			return this.map.get(key).toString();		}	}		public String [] getValues(String key) {		Object obj = this.map.get(key);		if( obj instanceof String ) {			return new String[]{(String) obj};		} else if( obj instanceof String[] ) {			return (String[])obj;		} else {			return new String[0];		}	}			/**	 * 금전형태나 timestamp형태에서 ',',':'등의 문자를 제거한다.	 * @param name	 * @return	 */	protected String getDelemeterFormat(String value) {		String formatValue = value.replaceAll("[, :]", "");		return formatValue;	}	/**	 * 날짜 형태의 파라미터를 가공	 * yyyy-MM-dd / MM-dd-yyyy / yyyy-MMM-dd / MMM-dd-yyyy형태를 yyyyMMdd로 변경함	 * @param name	 * @return	 */	protected String getDateFormat(String value) {		String formatValue = "";				try {			// HoDate hd = new HoDate(this.getParameterDateFormat());						// logger.info(value + ":"+ this.getParameterDateFormat());						//formatValue = hd.getPlanValue(value, this.getParameterDateFormat());			formatValue = getHoDate().getPlanValue(value);		} catch(Exception e) {					}				return formatValue;	}		/**	 * 금전형태나 timestamp형태에서 ',',':'등의 문자를 제거한다.	 * @param name	 * @return	 */	protected String [] getValuesDelemeterFormat(String [] values) {		if( values == null  ) {			return new String[0];		}				String [] formatValue = new String[values.length];		for( int j=0 ; j<values.length ; j++ ) {			formatValue[j] = values[j].replaceAll("[, :]", "");		}				return formatValue;	}		/**	 * 날짜 형태의 파라미터를 가공	 * yyyy-MM-dd / MM-dd-yyyy / yyyy-MMM-dd / MMM-dd-yyyy형태를 yyyyMMdd로 변경함	 * @param name	 * @return	 */	protected String [] getValuesDateFormat(String [] values) {				if( values == null  ) {			return new String[0];		}				String [] formatValue = new String[values.length];				try {			// HoDate hd = new HoDate(this.getParameterDateFormat());			for( int i=0 ; i<values.length ; i++ ) {				formatValue[i] = "";								//formatValue = hd.getPlanValue(value[i], this.getParameterDateFormat());				formatValue[i] = getHoDate().getPlanValue(values[i]);			}		} catch(Exception e) {					}				return formatValue;	}			/**	 * 파라미터의 데이터 형태 yyyy/MM/dd or MM/dd/yyyy or MMM/dd/yyyy or yyyy-MM-dd	 * @return	 */	public String getParameterDateFormat() {		return parameterDateFormat;	}	/**	 * 파라미터의 데이터 형태 yyyy/MM/dd or MM/dd/yyyy or MMM/dd/yyyy or yyyy-MM-dd	 * @return	 */	public void setParameterDateFormat(String parameterDateFormat) {		this.parameterDateFormat = parameterDateFormat;	}		public Map getDisplayFormat() {		return this.displayFormat;	}	public HoConfig getHoConfig() {		return hoConfig;	}	public void setHoConfig(HoConfig hoConfig) {		this.hoConfig = hoConfig;	}		/**	 * entry의 length가 가장 큰 값을 구한다.	 * @return	 */	public int maxLengthEntry() {		int maxLength = 0;				String key = null;				Set keySet = this.map.keySet();		Iterator it = keySet.iterator();				while(it.hasNext()) {			key = (String) it.next();			if( getValues(key).length > maxLength ) {				maxLength = getValues(key).length;			}		}				return maxLength;	}		/**	 * 실제 HoQueryParameterMap을 만든다.	 * @param value	 * @param type	 */	private HoQueryParameterMap makeHoQueryParameterMap(int type) {		HoQueryParameterMap value = new HoQueryParameterMap();		String key = null;				Set keySet = this.map.keySet();		Iterator it = keySet.iterator();				while(it.hasNext()) {			key = (String) it.next();						try {				// logger.info(key + ":" + getType(key));				switch( getType(key)  ) {					case  ARRAY_YMD: 						value.put(key.toUpperCase(), getValuesDateFormat(getValues(key)));						break;					case  ARRAY_HMS: 					case  ARRAY_HM: 					case  ARRAY_CURRENCY: 						value.put(key.toUpperCase(), getValuesDelemeterFormat(getValues(key)));						break;					case  ARRAY_STRING: 						value.put(key.toUpperCase(), getValues(key));						break;					case  YMD: 						if(type == SEARCH ) {							value.put(key.toUpperCase(), getDateFormat(get(key)));						} else if(type == DETAIL) {							value.put(key.toUpperCase(), getDateFormat(get(key)));						} else if(type == ARRAYED) {							value.put(key.toUpperCase(), getValuesDateFormat(getValues(key)));						} else if(type == META_DATA ) {							value.put(key.toUpperCase(), getDateFormat(get(key)));						}  						break;					case  HMS: 					case  HM: 					case  CURRENCY: 						if(type == SEARCH) {							value.put(key.toUpperCase(), getDelemeterFormat(get(key)));						} else if(type == DETAIL) {							value.put(key.toUpperCase(), getDelemeterFormat(get(key)));						} else if(type == ARRAYED) {							value.put(key.toUpperCase(), getValuesDelemeterFormat(getValues(key)));						} else if(type == META_DATA ) {							value.put(key.toUpperCase(), getDelemeterFormat(get(key)));						}  						break;					case  ARRAY_ABLE: 						if(type == SEARCH) {							value.put(key.toUpperCase()+"_ES", getSplit(get(key)));							value.put(key.toUpperCase(), get(key));						} else if(type == DETAIL) {							value.put(key.toUpperCase(), get(key));						} else if(type == ARRAYED) {							value.put(key.toUpperCase(), getValues(key));						} else if(type == META_DATA ) {							value.put(key.toUpperCase()+"_ES", getSplit(get(key)));							value.put(key.toUpperCase(), get(key));						}  					case  STRING: 						if(type == SEARCH) {							value.put(key.toUpperCase(), get(key));						} else if(type == DETAIL) {							value.put(key.toUpperCase(), get(key));						} else if(type == ARRAYED) {							value.put(key.toUpperCase(), getValues(key));						} else if(type == META_DATA ) {							value.put(key.toUpperCase(), get(key));						}  						break;					}				} catch(Exception e) {				e.printStackTrace();			}			}		return value;	}		public long getPageNo() {		return this.pageNo;	}		public long getPageRowCnt()  {		return this.pageRowCnt;	}}