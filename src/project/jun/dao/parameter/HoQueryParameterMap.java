package project.jun.dao.parameter;import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.ObjectInput;import java.io.ObjectInputStream;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;import java.util.TreeSet;import org.apache.log4j.Logger;import project.jun.util.HoUtil;import project.jun.was.parameter.HoParameter;import project.jun.was.result.exception.HoException;public class HoQueryParameterMap extends HashMap {	/**	 * 	 */	private static final long serialVersionUID = -8369036917075731525L;	protected static Logger          logger     = Logger.getLogger(HoQueryParameterMap.class); //Logger.getRootLogger();	/**	 * HashMap에 등록된 entry를 keyCase(default : 대문자) 에 따라 조회한다.	 */	public Object get(String key) {		Object obj = super.get(key.toUpperCase());				if( obj == null ) {			if( key.toUpperCase().endsWith("_ES")) {				obj = new String[0];			} else {				obj = "";			}		} 				return obj;	}	public Object put(String key, byte[] entry) throws IOException, ClassNotFoundException {		ByteArrayInputStream bis = new ByteArrayInputStream(entry);		ObjectInput in = new ObjectInputStream(bis);		Object o = in.readObject();				return super.put(key.toUpperCase(), o);		}	/**	 * HashMap에 entry를 keyCase(default : 대문자)에 따라 추가한다.	 */	public Object put(String key, Object entry) {		return super.put(key.toUpperCase(), entry == null ? "" : entry);		}		/**	 * short형을 Short객체로 wrap한후 HashMap에 추가한다.	 * (이미 해당 key값이 있을 경우에는 replace된다.)	 */	public Object put(String key, short entry) {		return this.put( key, new Short(entry));	} 		/**	 * int형을 Integer객체로 wrap한후 HashMap에 추가한다.	 * (이미 해당 key값이 있을 경우에는 replace된다.)	 */	public Object put(String key, int entry) {		return this.put( key, new Integer(entry));	} 		/**	 * long형을 Long객체로 wrap한후 HashMap에 추가한다.	 * (이미 해당 key값이 있을 경우에는 replace된다.)	 */	public Object put(String key, long entry) {		return this.put( key, new Long(entry));	} 		/**	 * float형을 Float객체로 wrap한후 HashMap에 추가한다.	 * (이미 해당 key값이 있을 경우에는 replace된다.)	 */	public Object put(String key, float entry) {		return this.put( key, new Float(entry));	} 		/**	 * double형을 Double객체로 wrap한후 HashMap에 추가한다.	 * (이미 해당 key값이 있을 경우에는 replace된다.)	 */	public Object put(String key, double entry) {		return this.put( key, new Double(entry));	}	/**	 * 이미 존재하는 key값에 entry를 추가할 경우 사용한다.	 * key가 존재하지 않는경우에 사용하면 추가만 되고,	 * key가 존재하는 경우에 사용하면 --> entry가 배열 형태로 변경되어 추가된다.	 */	public Object add(String key, Object entry) {		if( !this.containsKey(key.toUpperCase())) {			return super.put(key.toUpperCase(), entry);			} else {						return super.put(key.toUpperCase(), getNewEntryArray(key, entry));					}	}	/**	 * key값에 해당하는 savedEntry가 	 * 1. 배열일 경우 배열의 크기를 1 증가시킨후 추가할 entry를 추가한다.	 * 2. 배열이 아닌경우에는 length가 2인 배열을 생성후 첫번째배열([o])에는 savedEntry, 두번째배열([1])에는 entry를 추가한다.	 */	public Object getNewEntryArray(String key, Object entry) {		Object savedEntry = super.get(key.toUpperCase());		Object [] newEntry = null;		if( savedEntry instanceof Object [] ) {			newEntry = new Object [((Object [])savedEntry).length+1];			System.arraycopy(((Object [])savedEntry), 0, newEntry, 0, ((Object [])savedEntry).length);			newEntry[((Object [])savedEntry).length] = entry;		} else {			newEntry = new Object [2];			newEntry[0] = savedEntry;			newEntry[1] = entry;		}		return newEntry;	}	/**	 * short형을 Short객체로 wrap한후 HashMap에 추가한다.	 */	public Object add(String key, short entry) {		return this.put( key, new Short(entry));	} 		/**	 * int형을 Integer객체로 wrap한후 HashMap에 추가한다.	 */	public Object add(String key, int entry) {		return this.add( key, new Integer(entry));	} 		/**	 * long형을 Long객체로 wrap한후 HashMap에 추가한다.	 */	public Object add(String key, long entry) {		return this.add( key, new Long(entry));	} 		/**	 * float형을 Float객체로 wrap한후 HashMap에 추가한다.	 */	public Object add(String key, float entry) {		return this.add( key, new Float(entry));	} 		/**	 * double형을 Double객체로 wrap한후 HashMap에 추가한다.	 */	public Object add(String key, double entry) {		return this.add( key, new Double(entry));	}	/**	 * 파라미터를 복사한다.	 * @param wizParamter	 * @throws HoException	 */	public void copy(HoParameter wizParamter) throws HoException {		super.putAll(wizParamter.getParameterMap());	}	/**	 * 파라미터를 모두 배열로 복사한다.	 * @param wizParamter	 * @throws HoException	 */	public void copyToArray(HoParameter wizParamter) throws HoException {		super.putAll(wizParamter.getParameterMap());	}	/**	 * 파라미터를 복사한다.	 * @param wizParamter	 * @throws HoException	 */	public void copy(Map map) throws HoException {		super.putAll(map);	}			/**	 * 키값의 최고 길이를 구한다.	 * @return	 */	public int getMaxKeyLength(Set key) {		Iterator keyIt = key.iterator();		int length = 0;				String keyStr = null;		while(keyIt.hasNext()) {			keyStr = (String) keyIt.next();						if( keyStr.length() > length ) {				length = keyStr.length();			}					}		return length;	}			/**	 * 엔트리 값의 최고 길이를 구한다.	 * @return	 */	public int getMaxEntryLength() {		Set keySet = new TreeSet(this.keySet());		Iterator keyIt = keySet.iterator();		Object obj = null;		String key = null;		int length = 0;				while(keyIt.hasNext()) {			key = (String) keyIt.next();			obj = this.get(key);			if( obj instanceof Object []) {								if( length < ((Object [])obj).length ){					length = ((Object [])obj).length;				}			} else {				if( length < 1 ) {					length = 1;				} 			}					}				return length;	}		public String toString() {		StringBuffer sb = new StringBuffer(512);				int idx = 1;		Set keySet = new TreeSet(this.keySet());		Iterator keyIt = keySet.iterator();		String keyStr = null;				sb.append("HoQueryParameterMap [ Parameter Size : "+this.size()+"]\r\n");		int maxLength = getMaxKeyLength(keySet);		Object entry = null;				keyStr = "P_ACTION_FLAG";				sb.append("\t["+ HoUtil.lPad(String.valueOf(idx++), 3, " ") + "] ");		entry = this.get(keyStr);		sb.append(HoUtil.rPad(keyStr, maxLength , " "));		sb.append(" : " + entry.toString() );				while(keyIt.hasNext()) {			keyStr = (String) keyIt.next();			if( !keyStr.equals("P_ACTION_FLAG")) {				sb.append("\t["+ HoUtil.lPad(String.valueOf(idx++), 3, " ") + "] ");				entry = this.get(keyStr);				sb.append(HoUtil.rPad(keyStr, maxLength , " "));				if( entry instanceof Object [] ) {					sb.append(" : Object [" + ((Object[]) entry ).length + "]") ;					sb.append(" {") ;					for( int i=0 ; i<((Object[]) entry ).length; i++ ) {						if( i!=0 ) {							sb.append(", ");											}						sb.append(i+"="+ ((Object[]) entry )[i]) ;					}					sb.append('}') ;				} else {					sb.append(" : " + HoUtil.cutString(entry.toString(), 100, "... [has more]\r\n") );				}				if( idx % 5 == 0 ) {					sb.append("\r\n");				}			}		}		return sb.toString();	}}